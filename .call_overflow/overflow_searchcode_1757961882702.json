{
  "timestamp": 1757961882702,
  "toolName": "searchcode",
  "totalChunks": 1,
  "chunks": [
    {
      "type": "text",
      "text": "ByStepAccuracy / 10 +\\r\\n        adaptive.performance.adaptiveScore / 10\\r\\n      ),\\r\\n\\r\\n      memoryEfficiency: flash.performance.memoryEfficiency,\\r\\n      reasoningQuality: reasoning.performance.qualityImprovement,\\r\\n      adaptiveScore: adaptive.performance.adaptiveScore\\r\\n    };\\r\\n\\r\\n    return {\\r\\n      optimizedContent: reasoning.content,\\r\\n      toolRecommendations: base.toolRecommendations || [],\\r\\n      relevanceScores: base.relevanceScores || [],\\r\\n\\r\\n      // Enhanced performance metrics\\r\\n      performance,\\r\\n\\r\\n      // Detailed breakdown\\r\\n      optimizationBreakdown: {\\r\\n        flashAttention: {\\r\\n          tokenReduction: flash.performance.tokenReduction,\\r\\n          memoryEfficiency: flash.performance.memoryEfficiency,\\r\\n          attentionEfficiency: flash.performance.attentionEfficiency\\r\\n        },\\r\\n        reasoningModel: {\\r\\n          qualityImprovement: reasoning.performance.qualityImprovement,\\r\\n          stepByStepAccuracy: reasoning.performance.stepByStepAccuracy,\\r\\n          complexity: reasoning.reasoning ? reasoning.reasoning.complexity : 0.5\\r\\n        },\\r\\n        adaptiveLearning: {\\r\\n          adaptiveScore: adaptive.performance.adaptiveScore,\\r\\n          learningAccuracy: adaptive.performance.learningAccuracy,\\r\\n          historicalSamples: adaptive.learning.historicalSamples\\r\\n        },\\r\\n        baseOptimization: {\\r\\n          attention: base.performance ? base.performance.optimizationTime : 0,\\r\\n          tokenReduction: base.performance ? base.performance.tokenReduction : 0,\\r\\n          quality: base.performance ? base.performance.qualityImprovement : 0\\r\\n        }\\r\\n      }\\r\\n    };\\r\\n  }\\r\\n\\r\\n  // Store optimization history for future learning\\r\\n  storeOptimizationHistory(taskContext, result) {\\r\\n    const taskId = this.generateTaskId(taskContext);\\r\\n    const history = this.optimizationHistory.get(taskId) || [];\\r\\n\\r\\n    const historyEntry = {\\r\\n      timestamp: Date.now(),\\r\\n      taskContext: {\\r\\n        task: taskContext.currentTask,\\r\\n        complexity: taskContext.complexity\\r\\n      },\\r\\n      performance: result.performance,\\r\\n      techniques: result.techniques || [],\\r\\n      success: result.performance.combinedQualityImprovement > 15\\r\\n    };\\r\\n\\r\\n    history.push(historyEntry);\\r\\n\\r\\n    // Keep rolling history\\r\\n    if (history.length > 10) {\\r\\n      history.shift();\\r\\n    }\\r\\n\\r\\n    this.optimizationHistory.set(taskId, history);\\r\\n  }\\r\\n\\r\\n  // Generate task ID for history tracking\\r\\n  generateTaskId(taskContext) {\\r\\n    const taskHash = taskContext.currentTask\\r\\n      ? taskContext.currentTask.substring(0, 20).replace(/\\\\s+/g, '_')\\r\\n      : 'unknown_task';\\r\\n    return `${taskHash}_${taskContext.complexity || 'medium'}`;\\r\\n  }\\r\\n\\r\\n  // Get optimization statistics\\r\\n  getOptimizationStats() {\\r\\n    const stats = {\\r\\n      totalOptimizations: 0,\\r\\n      successfulOptimizations: 0,\\r\\n      averageImprovement: 0,\\r\\n      techniquesUsed: new Set(),\\r\\n      taskTypes: new Map()\\r\\n    };\\r\\n\\r\\n    for (const [taskId, history] of this.optimizationHistory) {\\r\\n      history.forEach(entry => {\\r\\n        stats.totalOptimizations++;\\r\\n        if (entry.success) stats.successfulOptimizations++;\\r\\n        stats.averageImprovement += entry.performance.combinedQualityImprovement;\\r\\n\\r\\n        entry.techniques.forEach(technique => stats.techniquesUsed.add(technique));\\r\\n\\r\\n        const taskType = entry.taskContext.task ? entry.taskContext.task.split(' ')[0] : 'unknown';\\r\\n        stats.taskTypes.set(taskType, (stats.taskTypes.get(taskType) || 0) + 1);\\r\\n      });\\r\\n    }\\r\\n\\r\\n    if (stats.totalOptimizations > 0) {\\r\\n      stats.averageImprovement /= stats.totalOptimizations;\\r\\n    }\\r\\n\\r\\n    stats.techniquesUsed = Array.from(stats.techniquesUsed);\\r\\n\\r\\n    return stats;\\r\\n  }\\r\\n}\\r\\n\\r\\nexport default NextGenOptimizationEngine;\",\n    \"startLine\": 0,\n    \"endLine\": 1147,\n    \"score\": 0.3426005420750477\n  },\n  {\n    \"file\": \"/config/workspace/mcp-repl/optimized-test-1757961454105/mcp-server/attention-optimization.js\",\n    \"content\": \"class AttentionOptimizationEngine {\\r\\n  constructor() {\\r\\n    this.relevanceScorer = new RelevanceScorer();\\r\\n    this.progressiveSummarizer = new ProgressiveSummarizer();\\r\\n    this.contextRecommender = new ContextAwareRecommender();\\r\\n    this.adaptiveContextManager = new AdaptiveContextManager();\\r\\n\\r\\n    this.optimizationStrategies = new Map([\\r\\n      ['relevance_scoring', this.optimizeRelevanceScoring.bind(this)],\\r\\n      ['progressive_summarization', this.optimizeProgressiveSummarization.bind(this)],\\r\\n      ['context_aware_recommendations', this.optimizeContextAwareRecommendations.bind(this)],\\r\\n      ['adaptive_context_windows', this.optimizeAdaptiveContextWindows.bind(this)]\\r\\n    ]);\\r\\n\\r\\n    this.performanceMetrics = {\\r\\n      optimizationTime: [],\\r\\n      tokenReduction: [],\\r\\n      qualityImprovement: [],\\r\\n      attentionEfficiency: []\\r\\n    };\\r\\n  }\\r\\n\\r\\n  async optimizeAttention(taskContext, availableTools, conversationHistory = []) {\\r\\n    const startTime = Date.now();\\r\\n\\r\\n    // Step 1: Analyze task complexity and context requirements\\r\\n    const complexityAnalysis = this.adaptiveContextManager.analyzeTaskComplexity(\\r\\n      taskContext.currentTask,\\r\\n      conversationHistory\\r\\n    );\\r\\n\\r\\n    // Step 2: Apply relevance-based content prioritization\\r\\n    const relevanceOptimization = await this.optimizeRelevanceScoring(taskContext);\\r\\n\\r\\n    // Step 3: Apply progressive summarization for large content\\r\\n    const summarizationOptimization = await this.optimizeProgressiveSummarization(taskContext);\\r\\n\\r\\n    // Step 4: Generate context-aware tool recommendations\\r\\n    const recommendationOptimization = await this.optimizeContextAwareRecommendations(\\r\\n      taskContext,\\r\\n      conversationHistory\\r\\n    );\\r\\n\\r\\n    // Step 5: Apply adaptive context window sizing\\r\\n    const contextOptimization = this.adaptiveContextManager.optimizeContext(\\r\\n      taskContext.content || '',\\r\\n      taskContext.currentTask,\\r\\n      conversationHistory\\r\\n    );\\r\\n\\r\\n    const optimizationTime = Date.now() - startTime;\\r\\n\\r\\n    // Calculate overall improvements\\r\\n    const overallImprovements = this.calculateOverallImprovements({\\r\\n      relevance: relevanceOptimization,\\r\\n      summarization: summarizationOptimization,\\r\\n      recommendations: recommendationOptimization,\\r\\n      context: contextOptimization\\r\\n    });\\r\\n\\r\\n    // Update performance metrics\\r\\n    this.updatePerformanceMetrics({\\r\\n      optimizationTime,\\r\\n      tokenReduction: overallImprovements.tokenReduction,\\r\\n      qualityImprovement: overallImprovements.qualityImprovement,\\r\\n      attentionEfficiency: overallImprovements.attentionEfficiency\\r\\n    });\\r\\n\\r\\n    return {\\r\\n      originalContext: {\\r\\n        tokens: taskContext.content ? taskContext.content.length / 4 : 0,\\r\\n        complexity: complexityAnalysis.complexity,\\r\\n        score: complexityAnalysis.score\\r\\n      },\\r\\n      optimizedContext: {\\r\\n        tokens: contextOptimization.optimizedTokens,\\r\\n        profile: contextOptimization.profile,\\r\\n        compressionApplied: contextOptimization.compressionApplied\\r\\n      },\\r\\n      toolRecommendations: recommendationOptimization,\\r\\n      contentPrioritization: relevanceOptimization,\\r\\n      summarization: summarizationOptimization,\\r\\n      overallImprovements,\\r\\n      performance: {\\r\\n        optimizationTime: optimizationTime + 'ms',\\r\\n        averageOptimizationTime: this.getAverageOptimizationTime(),\\r\\n        tokenReduction: overallImprovements.tokenReduction + '%',\\r\\n        qualityImprovement: overallImprovements.qualityImprovement + '%',\\r\\n        attentionEfficiency: overallImprovements.attentionEfficiency + '%'\\r\\n      }\\r\\n    };\\r\\n  }\\r\\n\\r\\n  async optimizeRelevanceScoring(taskContext) {\\r\\n    if (!taskContext.content) return { applied: false, reason: 'No content to score' };\\r\\n\\r\\n    const scoring = this.relevanceScorer.scoreContent(taskContext.content);\\r\\n    const prioritization = this.relevanceScorer.prioritizeChunks(taskContext.content, 50);\\r\\n\\r\\n    return {\\r\\n      applied: true,\\r\\n      totalScore: scoring.totalScore,\\r\\n      averageScore: scoring.averageScore,\\r\\n      highPriorityLines: scoring.lineScores.filter(item => item.score > 5).length,\\r\\n      estimatedImprovement: Math.min(scoring.totalScore / scoring.lineScores.length * 10, 40).toFixed(1) + '%'\\r\\n    };\\r\\n  }\\r\\n\\r\\n  async optimizeProgressiveSummarization(taskContext) {\\r\\n    if (!taskContext.content) return { applied: false, reason: 'No content to summarize' };\\r\\n\\r\\n    const reduction = this.progressiveSummarizer.estimateReduction(taskContext.content);\\r\\n    const summary = this.progressiveSummarizer.generateProgressiveSummary(taskContext.content, 'medium');\\r\\n\\r\\n    return {\\r\\n      applied: true,\\r\\n      originalTokens: reduction.originalTokens,\\r\\n      summaryTokens: reduction.summaryTokens,\\r\\n      reduction: reduction.reductionPercentage + '%',\\r\\n      followupQueriesReduced: reduction.followupQueriesReduced,\\r\\n      summaryPoints: summary.points.length,\\r\\n      estimatedImprovement: reduction.reductionPercentage + '%'\\r\\n    };\\r\\n  }\\r\\n\\r\\n  async optimizeContextAwareRecommendations(taskContext, conversationHistory) {\\r\\n    const analysis = this.contextRecommender.analyzeContext(\\r\\n      conversationHistory,\\r\\n      taskContext.currentTask\\r\\n    );\\r\\n    const recommendation = this.contextRecommender.generateRecommendation(analysis);\\r\\n\\r\\n    return {\\r\\n      applied: true,\\r\\n      topRecommendations: recommendation.recommendedTools.slice(0, 3),\\r\\n      confidence: recommendation.confidence,\\r\\n      estimatedImprovement: recommendation.estimatedImprovement,\\r\\n      reasoning: recommendation.reasoning\\r\\n    };\\r\\n  }\\r\\n\\r\\n  optimizeAdaptiveContextWindows(taskContext) {\\r\\n    // This is handled by the adaptiveContextManager in the main optimization\\r\\n    return { applied: false, reason: 'Handled in main optimization' };\\r\\n  }\\r\\n\\r\\n  calculateOverallImprovements(optimizations) {\\r\\n    const improvements = [];\\r\\n\\r\\n    if (optimizations.relevance.applied) {\\r\\n      improvements.push(parseFloat(optimizations.relevance.estimatedImprovement));\\r\\n    }\\r\\n\\r\\n    if (optimizations.summarization.applied) {\\r\\n      improvements.push(parseFloat(optimizations.summarization.estimatedImprovement));\\r\\n    }\\r\\n\\r\\n    if (optimizations.recommendations.applied) {\\r\\n      improvements.push(parseFloat(optimizations.recommendations.estimatedImprovement));\\r\\n    }\\r\\n\\r\\n    if (optimizations.context.reductionPercentage > 0) {\\r\\n      improvements.push(optimizations.context.reductionPercentage);\\r\\n    }\\r\\n\\r\\n    const avgImprovement = improvements.length > 0\\r\\n      ? improvements.reduce((sum, imp) => sum + imp, 0) / improvements.length\\r\\n      : 0;\\r\\n\\r\\n    // Calculate weighted improvements\\r\\n    const tokenReduction = Math.min(avgImprovement * 1.2, 85); // Cap at 85%\\r\\n    const qualityImprovement = Math.min(avgImprovement * 0.8, 50); // Cap at 50%\\r\\n    const attentionEfficiency = Math.min(avgImprovement * 1.5, 75); // Cap at 75%\\r\\n\\r\\n    return {\\r\\n      tokenReduction: tokenReduction.toFixed(1),\\r\\n      qualityImprovement: qualityImprovement.toFixed(1),\\r\\n      attentionEfficiency: attentionEfficiency.toFixed(1)\\r\\n    };\\r\\n  }\\r\\n\\r\\n  updatePerformanceMetrics(metrics) {\\r\\n    this.performanceMetrics.optimizationTime.push(metrics.optimizationTime);\\r\\n    this.performanceMetrics.tokenReduction.push(parseFloat(metrics.tokenReduction));\\r\\n    this.performanceMetrics.qualityImprovement.push(parseFloat(metrics.qualityImprovement));\\r\\n    this.performanceMetrics.attentionEfficiency.push(parseFloat(metrics.attentionEfficiency));\\r\\n\\r\\n    // Keep only last 100 measurements\\r\\n    Object.keys(this.performanceMetrics).forEach(key => {\\r\\n      if (this.performanceMetrics[key].length > 100) {\\r\\n        this.performanceMetrics[key] = this.performanceMetrics[key].slice(-100);\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  getAverageOptimizationTime() {\\r\\n    const times = this.performanceMetrics.optimizationTime;\\r\\n    return times.length > 0\\r\\n      ? (times.reduce((sum, time) => sum + time, 0) / times.length).toFixed(2) + 'ms'\\r\\n      : '0ms';\\r\\n  }\\r\\n\\r\\n  getPerformanceSummary() {\\r\\n    const summary = {};\\r\\n\\r\\n    Object.keys(this.performanceMetrics).forEach(key => {\\r\\n      const values = this.performanceMetrics[key];\\r\\n      if (values.length > 0) {\\r\\n        summary[key] = {\\r\\n          average: (values.reduce((sum, val) => sum + val, 0) / values.length).toFixed(2),\\r\\n          min: Math.min(...values).toFixed(2),\\r\\n          max: Math.max(...values).toFixed(2),\\r\\n          count: values.length\\r\\n        };\\r\\n      }\\r\\n    });\\r\\n\\r\\n    return summary;\\r\\n  }\\r\\n}\",\n    \"startLine\": 2,\n    \"endLine\": 222,\n    \"score\": 0.3385846421473361\n  },\n  {\n    \"file\": \"/config/workspace/mcp-repl/src/attention-optimization.js\",\n    \"content\": \"class AttentionOptimizationEngine {\\r\\n  constructor() {\\r\\n    this.relevanceScorer = new RelevanceScorer();\\r\\n    this.progressiveSummarizer = new ProgressiveSummarizer();\\r\\n    this.contextRecommender = new ContextAwareRecommender();\\r\\n    this.adaptiveContextManager = new AdaptiveContextManager();\\r\\n\\r\\n    this.optimizationStrategies = new Map([\\r\\n      ['relevance_scoring', this.optimizeRelevanceScoring.bind(this)],\\r\\n      ['progressive_summarization', this.optimizeProgressiveSummarization.bind(this)],\\r\\n      ['context_aware_recommendations', this.optimizeContextAwareRecommendations.bind(this)],\\r\\n      ['adaptive_context_windows', this.optimizeAdaptiveContextWindows.bind(this)]\\r\\n    ]);\\r\\n\\r\\n    this.performanceMetrics = {\\r\\n      optimizationTime: [],\\r\\n      tokenReduction: [],\\r\\n      qualityImprovement: [],\\r\\n      attentionEfficiency: []\\r\\n    };\\r\\n  }\\r\\n\\r\\n  async optimizeAttention(taskContext, availableTools, conversationHistory = []) {\\r\\n    const startTime = Date.now();\\r\\n\\r\\n    // Step 1: Analyze task complexity and context requirements\\r\\n    const complexityAnalysis = this.adaptiveContextManager.analyzeTaskComplexity(\\r\\n      taskContext.currentTask,\\r\\n      conversationHistory\\r\\n    );\\r\\n\\r\\n    // Step 2: Apply relevance-based content prioritization\\r\\n    const relevanceOptimization = await this.optimizeRelevanceScoring(taskContext);\\r\\n\\r\\n    // Step 3: Apply progressive summarization for large content\\r\\n    const summarizationOptimization = await this.optimizeProgressiveSummarization(taskContext);\\r\\n\\r\\n    // Step 4: Generate context-aware tool recommendations\\r\\n    const recommendationOptimization = await this.optimizeContextAwareRecommendations(\\r\\n      taskContext,\\r\\n      conversationHistory\\r\\n    );\\r\\n\\r\\n    // Step 5: Apply adaptive context window sizing\\r\\n    const contextOptimization = this.adaptiveContextManager.optimizeContext(\\r\\n      taskContext.content || '',\\r\\n      taskContext.currentTask,\\r\\n      conversationHistory\\r\\n    );\\r\\n\\r\\n    const optimizationTime = Date.now() - startTime;\\r\\n\\r\\n    // Calculate overall improvements\\r\\n    const overallImprovements = this.calculateOverallImprovements({\\r\\n      relevance: relevanceOptimization,\\r\\n      summarization: summarizationOptimization,\\r\\n      recommendations: recommendationOptimization,\\r\\n      context: contextOptimization\\r\\n    });\\r\\n\\r\\n    // Update performance metrics\\r\\n    this.updatePerformanceMetrics({\\r\\n      optimizationTime,\\r\\n      tokenReduction: overallImprovements.tokenReduction,\\r\\n      qualityImprovement: overallImprovements.qualityImprovement,\\r\\n      attentionEfficiency: overallImprovements.attentionEfficiency\\r\\n    });\\r\\n\\r\\n    return {\\r\\n      originalContext: {\\r\\n        tokens: taskContext.content ? taskContext.content.length / 4 : 0,\\r\\n        complexity: complexityAnalysis.complexity,\\r\\n        score: complexityAnalysis.score\\r\\n      },\\r\\n      optimizedContext: {\\r\\n        tokens: contextOptimization.optimizedTokens,\\r\\n        profile: contextOptimization.profile,\\r\\n        compressionApplied: contextOptimization.compressionApplied\\r\\n      },\\r\\n      toolRecommendations: recommendationOptimization,\\r\\n      contentPrioritization: relevanceOptimization,\\r\\n      summarization: summarizationOptimization,\\r\\n      overallImprovements,\\r\\n      performance: {\\r\\n        optimizationTime: optimizationTime + 'ms',\\r\\n        averageOptimizationTime: this.getAverageOptimizationTime(),\\r\\n        tokenReduction: overallImprovements.tokenReduction + '%',\\r\\n        qualityImprovement: overallImprovements.qualityImprovement + '%',\\r\\n        attentionEfficiency: overallImprovements.attentionEfficiency + '%'\\r\\n      }\\r\\n    };\\r\\n  }\\r\\n\\r\\n  async optimizeRelevanceScoring(taskContext) {\\r\\n    if (!taskContext.content) return { applied: false, reason: 'No content to score' };\\r\\n\\r\\n    const scoring = this.relevanceScorer.scoreContent(taskContext.content);\\r\\n    const prioritization = this.relevanceScorer.prioritizeChunks(taskContext.content, 50);\\r\\n\\r\\n    return {\\r\\n      applied: true,\\r\\n      totalScore: scoring.totalScore,\\r\\n      averageScore: scoring.averageScore,\\r\\n      highPriorityLines: scoring.lineScores.filter(item => item.score > 5).length,\\r\\n      estimatedImprovement: Math.min(scoring.totalScore / scoring.lineScores.length * 10, 40).toFixed(1) + '%'\\r\\n    };\\r\\n  }\\r\\n\\r\\n  async optimizeProgressiveSummarization(taskContext) {\\r\\n    if (!taskContext.content) return { applied: false, reason: 'No content to summarize' };\\r\\n\\r\\n    const reduction = this.progressiveSummarizer.estimateReduction(taskContext.content);\\r\\n    const summary = this.progressiveSummarizer.generateProgressiveSummary(taskContext.content, 'medium');\\r\\n\\r\\n    return {\\r\\n      applied: true,\\r\\n      originalTokens: reduction.originalTokens,\\r\\n      summaryTokens: reduction.summaryTokens,\\r\\n      reduction: reduction.reductionPercentage + '%',\\r\\n      followupQueriesReduced: reduction.followupQueriesReduced,\\r\\n      summaryPoints: summary.points.length,\\r\\n      estimatedImprovement: reduction.reductionPercentage + '%'\\r\\n    };\\r\\n  }\\r\\n\\r\\n  async optimizeContextAwareRecommendations(taskContext, conversationHistory) {\\r\\n    const analysis = this.contextRecommender.analyzeContext(\\r\\n      conversationHistory,\\r\\n      taskContext.currentTask\\r\\n    );\\r\\n    const recommendation = this.contextRecommender.generateRecommendation(analysis);\\r\\n\\r\\n    return {\\r\\n      applied: true,\\r\\n      topRecommendations: recommendation.recommendedTools.slice(0, 3),\\r\\n      confidence: recommendation.confidence,\\r\\n      estimatedImprovement: recommendation.estimatedImprovement,\\r\\n      reasoning: recommendation.reasoning\\r\\n    };\\r\\n  }\\r\\n\\r\\n  optimizeAdaptiveContextWindows(taskContext) {\\r\\n    // This is handled by the adaptiveContextManager in the main optimization\\r\\n    return { applied: false, reason: 'Handled in main optimization' };\\r\\n  }\\r\\n\\r\\n  calculateOverallImprovements(optimizations) {\\r\\n    const improvements = [];\\r\\n\\r\\n    if (optimizations.relevance.applied) {\\r\\n      improvements.push(parseFloat(optimizations.relevance.estimatedImprovement));\\r\\n    }\\r\\n\\r\\n    if (optimizations.summarization.applied) {\\r\\n      improvements.push(parseFloat(optimizations.summarization.estimatedImprovement));\\r\\n    }\\r\\n\\r\\n    if (optimizations.recommendations.applied) {\\r\\n      improvements.push(parseFloat(optimizations.recommendations.estimatedImprovement));\\r\\n    }\\r\\n\\r\\n    if (optimizations.context.reductionPercentage > 0) {\\r\\n      improvements.push(optimizations.context.reductionPercentage);\\r\\n    }\\r\\n\\r\\n    const avgImprovement = improvements.length > 0\\r\\n      ? improvements.reduce((sum, imp) => sum + imp, 0) / improvements.length\\r\\n      : 0;\\r\\n\\r\\n    // Calculate weighted improvements\\r\\n    const tokenReduction = Math.min(avgImprovement * 1.2, 85); // Cap at 85%\\r\\n    const qualityImprovement = Math.min(avgImprovement * 0.8, 50); // Cap at 50%\\r\\n    const attentionEfficiency = Math.min(avgImprovement * 1.5, 75); // Cap at 75%\\r\\n\\r\\n    return {\\r\\n      tokenReduction: tokenReduction.toFixed(1),\\r\\n      qualityImprovement: qualityImprovement.toFixed(1),\\r\\n      attentionEfficiency: attentionEfficiency.toFixed(1)\\r\\n    };\\r\\n  }\\r\\n\\r\\n  updatePerformanceMetrics(metrics) {\\r\\n    this.performanceMetrics.optimizationTime.push(metrics.optimizationTime);\\r\\n    this.performanceMetrics.tokenReduction.push(parseFloat(metrics.tokenReduction));\\r\\n    this.performanceMetrics.qualityImprovement.push(parseFloat(metrics.qualityImprovement));\\r\\n    this.performanceMetrics.attentionEfficiency.push(parseFloat(metrics.attentionEfficiency));\\r\\n\\r\\n    // Keep only last 100 measurements\\r\\n    Object.keys(this.performanceMetrics).forEach(key => {\\r\\n      if (this.performanceMetrics[key].length > 100) {\\r\\n        this.performanceMetrics[key] = this.performanceMetrics[key].slice(-100);\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  getAverageOptimizationTime() {\\r\\n    const times = this.performanceMetrics.optimizationTime;\\r\\n    return times.length > 0\\r\\n      ? (times.reduce((sum, time) => sum + time, 0) / times.length).toFixed(2) + 'ms'\\r\\n      : '0ms';\\r\\n  }\\r\\n\\r\\n  getPerformanceSummary() {\\r\\n    const summary = {};\\r\\n\\r\\n    Object.keys(this.performanceMetrics).forEach(key => {\\r\\n      const values = this.performanceMetrics[key];\\r\\n      if (values.length > 0) {\\r\\n        summary[key] = {\\r\\n          average: (values.reduce((sum, val) => sum + val, 0) / values.length).toFixed(2),\\r\\n          min: Math.min(...values).toFixed(2),\\r\\n          max: Math.max(...values).toFixed(2),\\r\\n          count: values.length\\r\\n        };\\r\\n      }\\r\\n    });\\r\\n\\r\\n    return summary;\\r\\n  }\\r\\n}\",\n    \"startLine\": 2,\n    \"endLine\": 222,\n    \"score\": 0.3385846421473361\n  },\n  {\n    \"file\": \"/config/workspace/mcp-repl/optimized-test-1757961454105/mcp-server/arm64-safe-server.js\",\n    \"content\": \"function logAndReturn(response, startTime) {\\r\\n  const responseTime = Date.now() - startTime;\\r\\n  performanceMetrics.totalResponseTime += responseTime;\\r\\n\\r\\n  // Log performance metrics every 100 requests\\r\\n  if (performanceMetrics.requestCount % 100 === 0) {\\r\\n    const avgResponseTime = performanceMetrics.totalResponseTime / performanceMetrics.requestCount;\\r\\n    const cacheHitRate = (performanceMetrics.cacheHits / performanceMetrics.requestCount * 100).toFixed(1);\\r\\n\\r\\n    console.error(`[PERFORMANCE] Requests: ${performanceMetrics.requestCount}, Avg: ${avgResponseTime.toFixed(1)}ms, Cache Hit Rate: ${cacheHitRate}%`);\\r\\n  }\\r\\n\\r\\n  return response;\\r\\n}\",\n    \"startLine\": 215,\n    \"endLine\": 229,\n    \"score\": 0.33307251878630534\n  },\n  {\n    \"file\": \"/config/workspace/mcp-repl/src/arm64-safe-server.js\",\n    \"content\": \"function logAndReturn(response, startTime) {\\r\\n  const responseTime = Date.now() - startTime;\\r\\n  performanceMetrics.totalResponseTime += responseTime;\\r\\n\\r\\n  // Log performance metrics every 100 requests\\r\\n  if (performanceMetrics.requestCount % 100 === 0) {\\r\\n    const avgResponseTime = performanceMetrics.totalResponseTime / performanceMetrics.requestCount;\\r\\n    const cacheHitRate = (performanceMetrics.cacheHits / performanceMetrics.requestCount * 100).toFixed(1);\\r\\n\\r\\n    console.error(`[PERFORMANCE] Requests: ${performanceMetrics.requestCount}, Avg: ${avgResponseTime.toFixed(1)}ms, Cache Hit Rate: ${cacheHitRate}%`);\\r\\n  }\\r\\n\\r\\n  return response;\\r\\n}\",\n    \"startLine\": 215,\n    \"endLine\": 229,\n    \"score\": 0.33307251878630534\n  }\n]"
    }
  ],
  "estimatedTokens": 6281
}